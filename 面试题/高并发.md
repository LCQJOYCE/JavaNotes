一、内置锁

​		内置的锁机制来支持原子性，即同步代码块，

```java
synchronized(lock){ //作为锁的对象引用
    //代码段
}
```

每一个java对象都可以用作一个实现同步的锁，这些所被称为内置锁或监视器锁（Monitor Lock）。这相当于一种互斥锁。

二、synchronized的几种用法？

我认为主要是四种，也就是同步方法和同步代码块。同步方法分普通方法和静态方法，同步代码块里面的锁可以是类对象或者实例对象。这四种。当然普通方法的锁其实是实例对象，静态方法是类对象。

锁是和对象相关联的，每个对象有一把锁，为了执行synchronized语句，线程必须能够获得synchronized语句中表达式指定的对象的锁，一个对象只有一把锁，被一个线程获得之后它就不再拥有这把锁，线程在执行完synchronized语句后，将获得锁交还给对象。

​    在方法前面加上synchronized修饰符即可以将一个方法声明为同步化方法。同步化方法在执行之前获得一个锁。如果这是一个类方法，那么获得的锁是和声明方法的类相关的Class类对象的锁。如果这是一个实例方法，那么此锁是this对象的锁。

类锁与实例锁不相互阻塞，但相同的类锁，相同的当前实例锁，相同的对象锁会相互阻塞。如果访问不冲突可以分段锁，或者降低锁的粒度。提高并发量。

情况分析样例：

1、同步普通方法(锁实例对象) ：只能作用在单例上面，如果不是单例，同步方法锁将失效。因为是不同的实例。相当于两把锁。

2、同步静态方法（锁类本身）：同步静态方法，不管你有多少个类实例，同时只有一个线程能获取锁进入这个方法。

同步静态方法是类级别的锁，一旦任何一个线程进入这个方法，其他所有线程将无法访问这个类的任何同步类锁的方法。

3、同步类（锁类本身）：锁住效果和同步静态方法一样，都是类级别的锁，同时只有一个线程能访问带有同步类锁的方法。

同步块的用法，这里表示只有获取到这个类锁才能进入这个代码块。



```java
synchronized (TestSynchronized.class){
    
}
synchronized (this.getClass()) {
}
```

4、同步this实例(锁实例对象):同步块的用法，表示锁住整个当前对象实例，只有获取到这个实例的锁才能进入这个方法。

```java
synchronized (this) {
} //用法和同步普通方法锁一样，都是锁住整个当前实例。
```

一、CAS与非阻塞同步机制

CAS:比较并交换。利用了硬件对并发的支持。 一种乐观锁。

既提供原子性夜提供可见性。volatile只提供可见性。对符合操作不提供原子性。

非阻塞算法底层的并发原语来维持线程的安全性。

这些底层的原语通过原子变量类向外公开。

并发容器中的大多数实现类都是间接或直接的使用原子类，原子类又使用CAS操作。CAS是基于底层的JVM支持。

Unsafe这个类， 此类包含了低级（native硬件级别的原子操作）、不安全的操作集合。比如CAS操作。

ABA问题：

如果V的值由A变成B,在由B变成A。CAS操作判断的时候将会认为V没有被改变，但实际上这这个期间已经被别的线程改了，所以应该加一个版本号。这样就算是值相同但是版本号不同，那就知道已改变。